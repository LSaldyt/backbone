#!/usr/bin/env python3
import subprocess, time, sys, os
from contextlib import contextmanager

updateInterval = 60
waitInterval   = 1
appDir         = 'app'

@contextmanager
def directory(name):
    os.chdir(name)
    try:
        yield
    finally:
        os.chdir('..')

def get_sha():
    output = subprocess.check_output(['git', 'rev-parse', 'HEAD'])
    return output.decode('utf-8').strip()

def get_app_sha():
    if not os.path.isdir(appDir):
        return None
    with directory(appDir):
        return get_sha()

def update(url):
    if not os.path.isdir(appDir):
        subprocess.call(['git', 'clone', url, appDir])
    with directory(appDir):
        print('Pulling app')
        subprocess.call(['git', 'pull'])        # pull app's code
        subprocess.call(['bash', 'install.sh']) # run app
        return get_sha()

def main(args):
    url    = args[0]
    handle = None
    app_sha = get_app_sha()
    sha     = get_sha()
    last    = time.time()

    print('Waiting.', end='')
    while True:
        current = time.time()
        if current - last > updateInterval:
            last = current
            print('Checking for updates..')
            new_app_sha = update(url)
            print('Pulling backbone')
            subprocess.call(['git', 'pull']) # pull backbone's code
            new_sha = get_sha()
            if app_sha != new_app_sha:
                print('Updating app')
                # If our app has updated, restart it
                print('Re-running..')
                if handle is not None:
                    print('Killing..')
                    handle.kill()
                    handle = None
                app_sha = new_app_sha
            elif sha != new_sha:
                print('Updating backbone')
                # If backbone has updated, restart
                subprocess.call(['./backbone'] + args)
                return 0
            if handle is None:
                with directory(appDir):
                    handle = subprocess.Popen(['bash', 'run.sh'])
            print('Waiting.', end='')
        else:
            print('.', end='', flush=True)
            time.sleep(waitInterval)
    return 0

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
